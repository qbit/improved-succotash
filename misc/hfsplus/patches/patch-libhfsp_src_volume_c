Fix hpmount of newer HFS+ volumes: set vol->maxblocks when volume is
without HFS wrapper, so we can find the backup volume header.

Other changes unbreak the build.

Index: libhfsp/src/volume.c
--- libhfsp/src/volume.c.orig
+++ libhfsp/src/volume.c
@@ -323,7 +323,8 @@ void* volume_writefork(void *p, hfsp_fork_raw* f)
  */
 static int volume_readbuf(hfsp_vh* vh, void* p)
 {
-    if ( (vh->signature	= bswabU16_inc(p)) != HFSP_VOLHEAD_SIG) 
+    vh->signature	= bswabU16_inc(p);
+    if (vh->signature != HFSP_VOLHEAD_SIG) 
 	HFSP_ERROR(-1, "This is not a HFS+ volume");
     vh->version	    	= bswabU16_inc(p);
     vh->attributes   	= bswabU32_inc(p); 
@@ -345,7 +346,7 @@ static int volume_readbuf(hfsp_vh* vh, void* p)
     vh->write_count	= bswabU32_inc(p);
     vh->encodings_bmp	= bswabU64_inc(p);
     memcpy(vh->finder_info, p, 32); 
-    ((char*) p) += 32; // finderinfo is not used by now
+    p = (((char *)p) + 32); // finderinfo is not used by now
     p = volume_readfork(p, &vh->alloc_file );
     p = volume_readfork(p, &vh->ext_file   );
     p = volume_readfork(p, &vh->cat_file   );
@@ -381,7 +382,7 @@ static int volume_writebuf(hfsp_vh* vh, void* p)
     bstoreU32_inc(p, vh->write_count	);
     bstoreU64_inc(p, vh->encodings_bmp	);
     memcpy(p, vh->finder_info, 32); 
-    ((char*) p) += 32; // finderinfo is not used by now
+    p = (((char *)p) + 32); // finderinfo is not used by now
     p = volume_writefork(p, &vh->alloc_file );
     p = volume_writefork(p, &vh->ext_file   );
     p = volume_writefork(p, &vh->cat_file   );
@@ -417,12 +418,12 @@ static int volume_read_wrapper(volume * vol, hfsp_vh* 
   
 	UInt16	embeds, embedl;		/* Start/lenght of embedded area in blocks */
 	
-	((char*) p) += 0x12;		/* skip unneeded HFS vol fields */
+	p = (((char *)p) + 0x12);	/* skip unneeded HFS vol fields */
 	drAlBlkSiz = bswabU32_inc(p);	/* offset 0x14 */
-	((char*) p) += 0x4;		/* skip unneeded HFS vol fields */
+	p = (((char *)p) + 0x4);	/* skip unneeded HFS vol fields */
 	drAlBlSt    = bswabU16_inc(p);	/* offset 0x1C */
 	
-	((char*) p) += 0x5E;		/* skip unneeded HFS vol fields */
+	p = (((char *)p) + 0x5E);	/* skip unneeded HFS vol fields */
 	signature = bswabU16_inc(p);	/* offset 0x7C, drEmbedSigWord */
 	if (signature != HFSP_VOLHEAD_SIG)
 	    HFSP_ERROR(-1, "This looks like a normal HFS volume");
@@ -439,7 +440,11 @@ static int volume_read_wrapper(volume * vol, hfsp_vh* 
     else if (signature == HFSP_VOLHEAD_SIG) /* Native HFS+ volume */
     {
 	p = buf; // Restore to begin of block
-	return volume_readbuf(vh, p);
+	if (volume_readbuf(vh, p))
+	    return -1;
+	// Need maxblocks in sectors
+	vol->maxblocks = vh->total_blocks * (vh->blocksize / HFSP_BLOCKSZ);
+	return 0;
     } else
 	 HFSP_ERROR(-1, "Neither Wrapper nor native HFS+ volume header found");
     
